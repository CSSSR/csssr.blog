---
title: 'Безболезненный линтинг CSS с помощью stylelint'
coverImageAlt: 'Как настроить линтинг стилей на проекте так, чтобы не было больно ни при разработке, ни на code review'
author: 'v1z'
date: '2018-12-05'
tag: 'Web-development'
---

**Н**екоторые приемы, описанные в&nbsp;статье, ориентированы на&nbsp;использование PostCSS (в&nbsp;связке с&nbsp;<nobr>css-modules</nobr> и&nbsp;webpack), однако они с&nbsp;легкостью адаптируются под LESS / SASS / ванильный CSS.


## Часть I. Кодстайл vs личные предпочтения. Делаем одинаково
Рано или поздно перед любой командой разработчиков встаёт вопрос о&nbsp;внедрении стандартов написания кода и&nbsp;подключении линтеров на&nbsp;проект. Стандартизация кода позволяет:
+ <span class="bold">быстрее проводить code review</span>, так как полностью убирается необходимость следить за&nbsp;общим форматированием и&nbsp;распространёнными ошибками (благодаря <span class="no-wrap">`--fix`</span> флагу);
+ <span class="bold">упростить работу с&nbsp;компонентами&nbsp;других членов команды</span> &mdash;&nbsp;за&nbsp;счёт одинакового порядка свойств/селекторов вы&nbsp;всегда знаете, в&nbsp;каком именно месте искать проблемное свойство/селектор при рефакторинге/поддержке;
+ <span class="bold">быстрее вводить в&nbsp;проект новых разработчиков</span>, так как полностью пропадет необходимость объяснять все договоренности о&nbsp;кодстайле. Здесь стоит отметить, что в&nbsp;идеале все ваши стандарты написания кода должны проверяться линтером, если линтер не&nbsp;может проверить <nobr>какой-либо</nobr> кейс&nbsp;&mdash; не&nbsp;вводите такое требование к&nbsp;коду.

С&nbsp;другой стороны, у&nbsp;каждого разработчика есть свой собственный стиль, к&nbsp;которому он&nbsp;привык. Вспомните, как вы&nbsp;обычно пишете стили&nbsp;&mdash; скорее всего, правила добавляются в&nbsp;рандомном порядке. И&nbsp;если стандарты на&nbsp;проекте отличаются от&nbsp;личных предпочтений, а&nbsp;линтер настроен так, что даже локальная сборка не&nbsp;будет запускаться/пересобираться при наличии ошибок линтера&nbsp;&mdash; эффективность разработки падает в&nbsp;разы, огромное количество времени уходит на&nbsp;то, чтобы привести код в&nbsp;соответствие стандартам, и&nbsp;это больно. <span class="bold">Очень больно</span>.


## Часть II. Общее форматирование. Делаем красиво
Под общим форматированием я&nbsp;имею в&nbsp;виду все правила stylelint, отвечающие непосредственно за&nbsp;внешний вид кода и&nbsp;никак не&nbsp;влияющие на&nbsp;его работу. Разделять&nbsp;ли селекторы пустой строкой, переносить каждое правило на&nbsp;новую строку или писать все правила в&nbsp;одну линию? Отделять&nbsp;ли открывающую фигурную скобку селектора пробелом, писать <nobr>hex-цвета</nobr> в&nbsp;сокращённом или длинном виде, оставлять или опускать ведущие нули у&nbsp;чисел? Всё это (и&nbsp;еще многое другое) относится только к&nbsp;форматированию и&nbsp;на&nbsp;работу ваших стилей никак не&nbsp;влияет.

### Все пишут по-разному
Взгляните на&nbsp;примеры ниже&nbsp;&mdash; на&nbsp;каждом из&nbsp;них реальный, работающий код, хотя манеры его написания очень различаются:

```scss
.main-info{
    padding: 0;
    padding-top: 21px;
    margin: 0;
    border: none;
    margin-bottom: 50px;
    &__field{
        display: flex;
        align-items: flex-end;
        margin-bottom: 19px;
    }
    &__field-name{
        color: $grey;
        font-size: 22px;
        font-weight: 700;
        margin-right: 18px;
    }
}
```
```css
.root {
  padding-top: 60px;
}

.title {
  margin: 0 auto 40px;
  width: 170px;
  height: 70px;
  color: transparent;
  background-image: url('./images/title.svg');
  background-size: contain;
  user-select: none;

  @media (--tablet-large) {
    margin: 0 auto 60px;
    width: 328px;
    height: 136px;
  }
}
```
```css
body
	font-family PTSansBold
.wrap
	width 1000px
	margin 0 auto
	background-image url(../images/background.png)
.wrap__header
	display flex
	justify-content space-between
.wrap__logo
	padding 62px 0 0 112px
.wrap__secret
	padding 48px 54px 0 0
.wrap__content
	padding 0 112px 73px 112px
```
<p class="image-caption">Абсолютно разные подходы к&nbsp;форматированию стилевых файлов</p>

Конечно&nbsp;же, использование определённых пре- или постпроцессоров накладывает свои ограничения, но&nbsp;некоторые из&nbsp;нюансов форматирования остаются всегда. Но&nbsp;представьте себе, что творилось&nbsp;бы на&nbsp;проекте без линтера, если&nbsp;бы на&nbsp;него одновременно пришли авторы трёх кодов выше. <span class="bold">Боль</span>.

### Линтим форматирование
По&nbsp;сути, подходов к&nbsp;решению проблемы стандартизации форматирования всего два.

Вы&nbsp;разрабатываете свой собственный кодстайл и&nbsp;прописываете правила линтера в&nbsp;соответствии с&nbsp;этими требованиями. В&nbsp;этом случае ваш `.stylelintrc` может выглядеть примерно так:
```json
{
    "rules": {
        "indentation": 2,
        "string-quotes": "single",
        "declaration-colon-space-before": "never",
        "declaration-colon-space-after": "never",
        "rule-empty-line-before": "never",
        "media-feature-range-operator-space-before": "never",
        "media-feature-range-operator-space-after": "never",
        "media-feature-colon-space-before": "never",
        "media-feature-colon-space-after": "never"
    }
}
```

Либо вы&nbsp;можете взять уже готовый кодстайл, написанный <nobr>какой-либо</nobr> известной компанией,
```zsh
npm install stylelint-config-airbnb --save-dev
```
и&nbsp;использовать его в&nbsp;виде расширения конфигурации линтера. `.stylelintrc` в&nbsp;таком случае приобретёт следующий вид:
```json
{
  "extends": "stylelint-config-airbnb"
}
```
Конечно, ничто не&nbsp;мешает вам расширить или изменить готовый набор правил на&nbsp;свой вкус, переопределив некоторые правила конфига вручную.

![image](/images/lint-your-css/formatting.gif)
<p class="image-caption">Результат работы линтера</p>

### [Prettier](https://prettier.io/){:target="_blank"}
В&nbsp;моей команде выбор был сделан в&nbsp;пользу кодстайла Prettier. На&nbsp;самом деле [его&nbsp;конфиг для&nbsp;stylelint](https://github.com/prettier/stylelint-config-prettier#stylelint-config-prettier){:target="_blank"} не&nbsp;добавляет никаких правил, а&nbsp;наоборот, <span class="bold">отключает</span> бОльшую их&nbsp;часть. Сделано это для того, чтобы отключить все пересекающиеся правила из&nbsp;предыдущих конфигов (конфиг Prettier должен подключаться последним), дабы они не&nbsp;конфликтовали с&nbsp;логикой форматирования, заложенной в&nbsp;Prettier.

Как следствие отключения правил линтера&nbsp;&mdash; в&nbsp;текстовом редакторе пропадают предупреждения об&nbsp;ошибках форматирования, так как stylelint вообще перестаёт наблюдать за&nbsp;этими правилами. Это требует от&nbsp;разработчиков не&nbsp;забывать запускать Prettier либо [через CLI](https://prettier.io/docs/en/cli.html){:target="_blank"}, либо через плагин для текстового редактора ([вот такой, к&nbsp;примеру, для VS&nbsp;Code](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode){:target="_blank"}).


## Часть III. Порядок свойств внутри селектора. Делаем структурированно
Порядок, в&nbsp;котором вы&nbsp;пишете свойства внутри селектора, очень важен. Это может быть менее очевидно для разработчиков, которые работают в&nbsp;одиночку, но&nbsp;становится очень значимым фактором при командной разработке.

Если все ваши свойства сгруппированы по&nbsp;логическому смыслу и&nbsp;отсортированы внутри этих групп, код становится более структурированным. Преимущества такой сортировки:
+ <span class="bold">более быстрое нахождение определённых свойств</span> (например, вы&nbsp;всегда уверены, что `position` идёт самым первым свойством, а&nbsp;`margin` всегда идут до&nbsp;`padding`);
+ <span class="bold">внедрение новых фич не&nbsp;снижает качество кода</span> (как&nbsp;бы вы&nbsp;ни&nbsp;были организованы в&nbsp;плане написания кода на&nbsp;первоначальном этапе разработки, чаще всего, к&nbsp;моменту выхода проекта на&nbsp;стадию поддержки эта организованность значительно снижается);
+ <span class="bold">упрощается работа с&nbsp;кодом, который писали не&nbsp;вы</span>, а&nbsp;другой разработчик команды.

### Реализация сортировки
Для достижения поставленной цели в&nbsp;виде сгруппированных и&nbsp;отсортированных свойств следует воспользоваться [плагином для stylelint](https://github.com/hudochenkov/stylelint-order#stylelint-order---){:target="_blank"}.
```zsh
npm install stylelint-order --save-dev
```
После установки плагина достаточно добавить его в&nbsp;список плагинов, а&nbsp;также указать нужный порядок свойств в&nbsp;`.stylelintrc`
```json
{
  "plugins": [
    "stylelint-order",
  ],
  "rules": {
    "order/properties-order": [
      "position",
      "z-index",
      "top",
      "right",
      "bottom",
      "left",
    ],
  },
}
```
Порядком расположения не&nbsp;перечисленных в&nbsp;конфиге свойств относительно перечисленных можно управлять с&nbsp;помощью необязательного параметра [unspecified](https://github.com/hudochenkov/stylelint-order/blob/master/rules/properties-order/README.md#unspecified-topbottombottomalphabeticalignore){:target="_blank"}.
```json
"order/properties-order": [
  [
    "position",
    "z-index",
  ],
  {
    unspecified: "bottom"
  }
]
```

![image](/images/lint-your-css/sorting.gif)
<p class="image-caption">Результат работы линтера</p>


## Часть IV. Очерёдность в «нестинге». Снижаем риски и&nbsp;повышаем читаемость
&laquo;Нестинг&raquo;, или вложенность&nbsp;&mdash; крайне удобный и&nbsp;мощный инструмент, в&nbsp;который умеют все пре- и&nbsp;постпроцессоры. Однако неумелое его использование открывает возможность выстрелить себе в&nbsp;ногу (чаще всего, <nobr>из-за</nobr> незнания того, как работает специфичность селекторов).

Если&nbsp;же говорить про кодстайл, то&nbsp;при командной разработке вы&nbsp;наверняка хотели&nbsp;бы иметь возможность управлять очерёдностью в&nbsp;нестинге. Ведь код, в&nbsp;котором очерёдность 'БЭМ модификатор&nbsp;&mdash; media&nbsp;&mdash; псевдоклассы&nbsp;&mdash; псевдоэлементы', будет ОЧЕНЬ сильно отличаться от&nbsp;кода с&nbsp;обратной очерёдностью.

![image](/images/lint-your-css/nestingOrder.png)
<p class="image-caption">Различные варианты сортировки в&nbsp;нестинге</p>

Так&nbsp;же как и&nbsp;одинаковый порядок свойств в&nbsp;селекторе, одинаковая очерёдность в&nbsp;нестинге позволяет облегчить работу с&nbsp;кодом, который писал другой разработчик команды, так как вы&nbsp;всегда уверены, в&nbsp;каком именно месте искать определенные вложенные правила. Плюс это страхует от&nbsp;ошибок при поддержке кода, когда, к&nbsp;примеру, к&nbsp;уже существующим media добавляется ещё одно, но&nbsp;в&nbsp;неправильной очерёдности. Добавьте к&nbsp;этому правило о&nbsp;максимальной глубине вложенности и&nbsp;запрет на&nbsp;любые селекторы внутри media (<nobr>т.е.</nobr> чтобы изменить эффект при наведении на&nbsp;планшетах, вы&nbsp;обязываете своих разработчиков вкладывать media в&nbsp;hover, а&nbsp;не&nbsp;наоборот)&nbsp;&mdash; и&nbsp;на&nbsp;выходе получите очень мощный инструмент стандартизации кода.

### Реализация сортировки
Данная сортировка достигается за&nbsp;счёт использования упомянутого выше плагина <nobr>stylelint-order</nobr>, возможный конфиг `.stylelintrc` может выглядеть так:
```json
{
  "plugins": [
    "stylelint-order",
  ],
  "rules": {
    "order/order": [
      "declarations",
      {
        "type": "at-rule",
        "name": "media"
      },
      {
        "type": "rule",
        "selector": "^&::(before|after)"
      },
      {
        "type": "rule",
        "selector": "^&:\\w"
      },
      {
        "type": "rule",
        "selector": "^&_"
      },
      {
        "type": "rule",
        "selector": "^."
      }
    ],
  },
}
```
Обратите особое внимание, что для определения вложенного правила [используются регулярные выражения](https://github.com/hudochenkov/stylelint-order/blob/master/rules/order/README.md#extended-rule-objects){:target="_blank"}.

![image](/images/lint-your-css/nesting.gif)
<p class="image-caption">Результат работы линтера</p>


## Часть V. Не форматированием единым. Заботимся о качестве
Как вы&nbsp;могли заметить, всё, о&nbsp;чём шла речь выше, касалось лишь форматирования кода, работал он&nbsp;при этом абсолютно одинаково. Но&nbsp;помимо соглашений о&nbsp;форматировании любой кодстайл включает себя также и&nbsp;соглашения о&nbsp;качестве кода.

Хотите запретить использование тегов или id&nbsp;в&nbsp;селекторах? Застраховаться от&nbsp;дублирования правил внутри селектора или дублирования самих селекторов? Запретить `!important`, ограничить максимальную глубину нестинга, запретить использование `em` или `px`? А&nbsp;может, запретить целые правила, вроде сокращённой записи `margin/padding/flex`? stylelint предоставляет огромное количество правил, отвечающих именно за&nbsp;такие ситуации. За&nbsp;счет их&nbsp;использования внутри команды достигается некое единообразие в&nbsp;самой логике написания стилевых файлов.

Помимо стандартных правил stylelint также стоит обратить внимание на&nbsp;[плагины](https://stylelint.io/user-guide/plugins/){:target="_blank"}, расширяющие возможности проверки кода&nbsp;&mdash; например, можно [запретить использование media без custom-media](https://github.com/csstools/stylelint-media-use-custom-media#media-use-custom-media-){:target="_blank"} или [запретить вкладывать селекторы внутрь media](https://github.com/adityavm/stylelint-at-rule-no-children#tldr){:target="_blank"}.

Использование таких правил очень сильно зависит от&nbsp;договоренностей внутри команды. Главный посыл здесь должен быть &laquo;не&nbsp;навреди&raquo;&nbsp;&mdash; обсуждайте внедрение правил с&nbsp;командой, ставьте их&nbsp;под сомнение, разбирайте все плюсы и&nbsp;минусы их&nbsp;использования. Хорошим маркером для подключения нового правила (или расширения уже подключенного) является момент, когда при прохождении code review ошибка встречается более двух раз, <nobr>т.е.</nobr> в&nbsp;первый раз разработчик поправил ошибку после замечания, но&nbsp;через некоторое время снова отправил на&nbsp;проверку код с&nbsp;такой&nbsp;же ошибкой.

![image](/images/lint-your-css/quality.png)
<p class="image-caption">&laquo;Качественные&raquo; ошибки линтера</p>


## Часть VI. Автоматизация процесса. Убираем боль
Итак, вы&nbsp;потратили достаточно времени на&nbsp;составление добротного конфига stylelint, который покрывает все требуемые вашим кодстайлом моменты&nbsp;&mdash; общее форматирование, различные сортировки правил, а&nbsp;также &laquo;качественные&raquo; нюансы. Следующий вопрос, который вам предстоит решить&nbsp;&mdash; &laquo;в&nbsp;какой момент запускать проверку линтера, и&nbsp;что должно происходить при наличии ошибок в&nbsp;этой проверке?&raquo;. Этот вопрос имеет огромное значение.

Представьте себе такую ситуацию&nbsp;&mdash; ваша система сборки (gulp/webpack/etc.) настроена таким образом, что проверка линтера запускается на&nbsp;каждое сохранение файла и&nbsp;при наличии ошибок не&nbsp;даёт обновить локальный сервер, <nobr>т.е.</nobr> вы&nbsp;не&nbsp;сможете увидеть результат внесённых изменений. Неважно, на&nbsp;какой стадии находится проект&nbsp;&mdash; на&nbsp;начальном этапе разработки самых мелких реиспользуемых компонент или&nbsp;же на&nbsp;этапе поддержки, когда код вносится в&nbsp;уже функционирующую систему с&nbsp;огромным количеством файлов и&nbsp;строк кода. Вы&nbsp;не&nbsp;увидите ни&nbsp;одного изменения до&nbsp;тех пор, пока не&nbsp;расставите все написанные правила в&nbsp;правильном порядке и&nbsp;не&nbsp;соблюдёте все <nobr>бест-практики</nobr>, предписанные кодстайлом. <span class="bold">Боль</span>.

Настроив систему сборки и/или сам линтер так, чтобы ошибки общего форматирования и&nbsp;сортировки не&nbsp;препятствовали обновлению локального сервера (к&nbsp;примеру, за&nbsp;счёт смены отображения ошибок в&nbsp;правилах на&nbsp;предупреждения), вы&nbsp;снизите боль, но&nbsp;не&nbsp;уберёте её полностью. Ведь большинство разработчиков, которые имеют хоть <nobr>какой-то</nobr> опыт работы на&nbsp;проектах с&nbsp;линтерами, пользуются плагинами для своих текстовых редакторов/IDE, чтобы ошибки и&nbsp;предупреждения линтеров подсвечивались в&nbsp;коде. Все эти подчёркивания и&nbsp;всплывающие попапы знатно мозолят глаза и&nbsp;прилично отвлекают от&nbsp;основной задачи&nbsp;&mdash; написания кода. Слёз перфекционистов вообще не&nbsp;счесть.

К&nbsp;великому облегчению, есть как минимум три способа, позволяющие полностью автоматизировать процесс линтинга и&nbsp;исправления всего, что связано с&nbsp;общим форматированием и&nbsp;сортировками правил. Но&nbsp;перед описанием этих способов стоит сказать об&nbsp;одном очень простом и&nbsp;одновременно крайне мощном подходе.

### Разделяй и властвуй
Скорее всего, вы&nbsp;заметили, что на&nbsp;приведённых выше в&nbsp;статье скриншотах, где был показан результат работы линтера, его запуск осуществлялся с&nbsp;флагом <span class="no-wrap">`--fix`</span>. В&nbsp;результате этого все ошибки исправлялись автоматически. И&nbsp;напротив, ошибки правил, о&nbsp;которых шла речь в&nbsp;V&nbsp;части статьи, невозможно исправить автоматически, для их&nbsp;решения необходимо непосредственное вмешательство разработчика.

Помимо <span class="no-wrap">`--fix`</span> флага существует ещё и&nbsp;такой флаг как `--config`, который позволяет указать путь к&nbsp;определённому конфигу, а&nbsp;не&nbsp;использовать для проверки дефолтный конфиг.&nbsp;Такая возможность позволяет <span class="bold">разделить правила для нашего кодстайла на&nbsp;два конфига</span>:
+ Первый (он&nbsp;же дефолтный, к&nbsp;примеру `.stylelintrc`) будет содержать только те&nbsp;правила, для исправления ошибок которых необходимо вмешательство разработчика (не&nbsp;работает автоисправление). Именно этот конфиг будет подгружаться в&nbsp;плагины текстовых редакторов / IDE для проверки кода в&nbsp;режиме реального времени. Это обеспечит следование &laquo;качественным&raquo; критериям кодстайла, не&nbsp;отвлекая разработчиков на&nbsp;вопросы общего форматирования/сортировок.
+ Второй конфиг (к&nbsp;примеру, `.stylelintrc-extended`) будет содержать <span class="bold">все правила из&nbsp;первого</span>, а&nbsp;также будет дополнен правилами для форматирования/сортировок. Вызов такого конфига будет всегда сопровождаться флагом <span class="no-wrap">`--fix`</span>, что обеспечит следующую логику: линтер самостоятельно исправит все ошибки, которые сможет, а&nbsp;затем проверит код на&nbsp;соответствие качественным критериям кодстайла. Прохождение такой проверки без ошибок будет сигналом о&nbsp;том, что код полностью соответствует кодстайлу и&nbsp;его можно отправлять в&nbsp;репозиторий проекта.

Также стоит отметить, что на&nbsp;этапе локальной работы с&nbsp;кодом запускать проверки линтера не&nbsp;имеет особого смысла. Другими словами &mdash; _<span class="bold">дайте разработчикам возможность писать код как можно быстрее</span>_, не&nbsp;создавайте для них лишних препятствий, ведь до&nbsp;тех пор, пока код примет окончательный вид, пригодный для отправки в&nbsp;репозиторий, он&nbsp;будет изменён великое множество раз.

### Автоматизация запуска линтера
Как уже упоминалось выше, есть как минимум три способа запуска линтера, обеспечивающие автоматизацию процесса проверки.

Первый&nbsp;&mdash; запуск линтера в&nbsp;момент сохранения файлов. Этого можно достичь за&nbsp;счёт настройки вашей системы сборки ([так&nbsp;&mdash; для webpack](https://github.com/webpack-contrib/stylelint-webpack-plugin#stylelint-webpack-plugin){:target="_blank"} и&nbsp;[вот так&nbsp;&mdash; для gulp](https://github.com/olegskl/gulp-stylelint#gulp-stylelint){:target="_blank"}). Лично мне не&nbsp;нравится этот подход по&nbsp;ряду причин:
+ из-за сортировок код перемешивается прямо у&nbsp;вас на&nbsp;глазах, что вызывает дискомфорт, <nobr>т.к.</nobr> теряется положение курсора на&nbsp;последнем месте изменения в&nbsp;редакторе, а&nbsp;также нарушается порядок действий для `cmd/ctrl + z` команды;
+ повышается задержка между сохранением файла и&nbsp;реальным отображением правок в&nbsp;браузере (hot reload), а&nbsp;ведь сохранений в&nbsp;течение рабочего дня может быть ОЧЕНЬ много;
+ нет гарантий того, что код с&nbsp;ошибками не&nbsp;попадёт в&nbsp;репозиторий.

Второй&nbsp;&mdash; запуск линтера перед созданием коммита (<nobr>т.к.</nobr> в&nbsp;репозитории хранится вся история коммитов, мы&nbsp;не&nbsp;можем полагаться именно на&nbsp;_момент отправки_ кода в&nbsp;него).
Преимущества подхода:
+ линтер не&nbsp;вмешивается в&nbsp;процесс активной разработки, автоисправления будут применены, только когда работа с&nbsp;кодом завершена;
+ количество запускаемых проверок снижается в&nbsp;разы, что повышает общую производительность процесса разработки;
+ <span class="bold">код с&nbsp;ошибками линтера не&nbsp;может попасть в&nbsp;репозиторий</span>, так как наличие ошибок при проверке просто не&nbsp;даст создать новый коммит (конечно&nbsp;же, флаг <span class="no-wrap">`--no-verify`</span> никто не&nbsp;отменял, но&nbsp;за&nbsp;его использование следует бить по&nbsp;рукам).

Именно реализацию такого подхода мы&nbsp;и&nbsp;рассмотрим далее. Заключается она в&nbsp;использовании прекоммит хука, запускающего проверку линтера (с&nbsp;расширенным конфигом и&nbsp;флагом <span class="no-wrap">`--fix`</span>) с&nbsp;помощью husky и&nbsp;<nobr>lint-staged</nobr>.

Третий способ заключается в&nbsp;использовании [CI (Continuous integration)](https://en.wikipedia.org/wiki/Continuous_integration){:target="_blank"}, проверка линтером в&nbsp;таком случае может быть проведена автоматически для каждого отдельного Pull/Merge Request. Такой подход обеспечивает чистоту и&nbsp;порядок в&nbsp;стабильной ветке проекта без необходимости запуска проверки для каждого отдельного коммита в&nbsp;<nobr>feature-ветках</nobr>.

### husky + lint-staged + prettier = ❤️❤️❤️
[husky](https://github.com/typicode/husky#husky){:target="_blank"}&nbsp;&mdash; инструмент, позволяющий использовать различные гит хуки, в&nbsp;том числе и&nbsp;прекоммит хук.

[lint-staged](https://github.com/okonet/lint-staged#-lint-staged----){:target="_blank"}&nbsp;&mdash; позволяет запускать линтер только для тех файлов, которые находятся в&nbsp;[«staged»](https://githowto.com/staging_changes){:target="_blank"} состоянии, а&nbsp;не&nbsp;прогонять проверку всего проекта целиком.

[prettier](https://github.com/prettier/prettier#opinionated-code-formatter){:target="_blank"}&nbsp;&mdash; форматтер кода, который будет отвечать за&nbsp;следование правилам общего форматирования (о&nbsp;них шла речь во&nbsp;второй части статьи) нашего кодстайла.

Перейдём к&nbsp;настройке этих инструментов для работы в&nbsp;связке. Первым делом установим зависимости:
```zsh
npm install prettier husky lint-staged stylelint-order stylelint-config-prettier stylelint-config-recommended --save-dev
```

Далее нужно настроить ваш `.package.json` следующим образом:
```json
{
  "devDependencies": {
    "husky": "^1.2.0",
    "lint-staged": "^8.1.0",
    "prettier": "^1.15.2",
    "stylelint": "^9.8.0",
    "stylelint-config-prettier": "^4.0.0",
    "stylelint-config-recommended": "^2.1.0",
    "stylelint-order": "^2.0.0"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "linters": {
      "*.css": [
        "prettier --write",
        "stylelint --fix --config ./.stylelintrc-format",
        "git add"
      ]
    }
  }
}
```

Для того, чтобы переопределить [дефолтные настройки prettier](https://prettier.io/docs/en/options.html){:target="_blank"}, можно создать `.prettierrc` файл в&nbsp;корне вашего проекта. Выглядеть он&nbsp;может, к&nbsp;примеру, так:
```json
{
  "singleQuote": true,
  "tabWidth": 4
}
```

Также убедитесь в&nbsp;том, что вы&nbsp;передаете нужный конфиг в&nbsp;строке с&nbsp;вызовом линтера (скорее всего, это будет не&nbsp;дефолтный `.stylelintrc`).

### Итоговый результат
Настроив связку инструментов по&nbsp;приведённым выше примерам, на&nbsp;выходе мы&nbsp;получим следующую логику работы линтера на&nbsp;проекте:
+ базовый конфиг `.stylelintrc` включает в&nbsp;себя только &laquo;качественные&raquo; правила, плагины для текстовых редакторов / IDE используют именно его;
+ на&nbsp;этапе локальной работы с&nbsp;кодом проверки линтера не&nbsp;запускаются и&nbsp;не&nbsp;препятствуют разработке;
+ в&nbsp;момент создания коммита для файлов, <span class="bold">которые находятся в&nbsp;&laquo;staged&raquo; состоянии</span>, сначала отработает prettier, пофиксив общее форматирование. Затем запустится stylelint с&nbsp;расширенным конфигом и&nbsp;<span class="no-wrap">`--fix`</span> флагом, пофиксив сортировки правил и&nbsp;нестинга. Далее проводится проверка &laquo;качественных&raquo; правил, и&nbsp;в&nbsp;случае наличия ошибок коммит не&nbsp;будет создан. Если&nbsp;же ошибок нет, то&nbsp;все изменения, внесённые в&nbsp;результате автоисправлений, <span class="bold">будут автоматически добавлены в&nbsp;&laquo;staged&raquo; состояние</span> и&nbsp;коммит будет создан.

Допустим, что ваш итоговый конфиг имеет следующий вид:
```json
// .stylelintrc
{
  "rules": {
    "declaration-block-no-imortant": true,
    "property-blacklist": ["flex"],
    "unit-blacklist": ["em", "rem"],
  },
}
```
```json
// .stylelint-format
{
  "extends": [
    "stylelint-config-recommended",
    "stylelint-config-prettier",
  ],
  "plugins": [
    "stylelint-order",
  ],
  "rules": {
    "declaration-block-no-imortant": true,
    "indentation": 2,
    "rule-empty-line-before": "always",
    "at-rule-empty-line-before": "always",
    "property-blacklist": ["flex"],
    "unit-blacklist": ["em", "rem"],
    "order/order": [
      "declarations",
      {
        "type": "at-rule",
        "name": "media",
      },
      {
        "type": "rule",
        "selector": "^&:\\w"
      },
      {
        "type": "rule",
        "selector": "^&_"
      },
    ],
    "order/properties-order": [
      [
        "position",
        "top",
        "right",
        "bottom",
        "left",
      ],
      {
        unspecified: "bottom",
      }
    ],
  },
}
```
```json
// .package.json
{
  "devDependencies": {
    "husky": "^1.1.3",
    "lint-staged": "^8.0.4",
    "prettier": "^1.15.2",
    "stylelint": "^9.8.0",
    "stylelint-config-prettier": "^4.0.0",
    "stylelint-config-recommended": "^2.1.0",
    "stylelint-order": "^1.0.0"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "linters": {
      "*.css": [
        "prettier --write",
        "stylelint --fix --config ./.stylelintrc-format",
        "git add"
      ]
    }
  }
}
```
Тогда работа линтера будет выглядеть так (обратите внимание, что в&nbsp;staged состоянии находится только один стилевой файл):

![image](/images/lint-your-css/fail.gif)
<p class="image-caption">Попытка коммита вызывает прекоммит хук и&nbsp;автоисправление форматирования. Линтер падает с&nbsp;ошибками на&nbsp;&laquo;качественных&raquo; правилах, внесённые prettier изменения форматирования при этом сохраняются</p>

![image](/images/lint-your-css/success.gif)
<p class="image-caption">Пример успешного коммита без ошибок в&nbsp;&laquo;качественных&raquo; правилах</p>


## Заключение
С&nbsp;каждым днем stylelint становится всё мощнее, дополняясь новыми правилами и&nbsp;возможностями для автоматических исправлений. Так что если вы&nbsp;ещё не&nbsp;используете данный инструмент, я&nbsp;очень надеюсь, что после прочтения этой статьи вы&nbsp;хотя&nbsp;бы попробуете внедрить его на&nbsp;свои проекты. Также некоторые подходы, описанные в&nbsp;статье, применимы к&nbsp;линтингу не&nbsp;только стилевых файлов, но&nbsp;и, к&nbsp;примеру, JSX файлов, но&nbsp;это уже совсем другая история&hellip;

Для тех&nbsp;же из&nbsp;вас, кто захочет поучаствовать в&nbsp;разработке новых или улучшении уже существующих фич, разработчики stylelint подготовили [хороший гайд](https://github.com/stylelint/stylelint/blob/master/docs/developer-guide/rules.md#working-on-rules){:target="_blank"}.

Конфиги линтера, которые используются в&nbsp;моей команде, вы&nbsp;можете [найти тут](https://github.com/v1z/linters-example){:target="_blank"}.

Спасибо за внимание!
